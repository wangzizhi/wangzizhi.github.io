<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Css布局]]></title>
      <url>/2017/11/09/CSS%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h2><p>页面布局主要是存在于浏览器的渲染过程中，好的布局方式不仅可以提高页面显示的整体效果，更能在一定程度上决定了一个页面的架构是否合理有效。</p>
<h2 id="布局演变史"><a href="#布局演变史" class="headerlink" title="布局演变史"></a>布局演变史</h2><p>随着整个Web在不断的演进，那么为Web服务的理念与技术等等也是在不断的进行演化。当然Web布局，它也在Web不同的演化过程也有相应的演进。</p>
<p>在Web布局整个演进过程当中，经历了表格布局、定位布局、浮动布局、Flexbox布局等布局模式。除了这些我们常看到的布局之外，即将还会有Grid（网格布局）、Shapes（图形布局）、Regions（区域布局）这些现代的布局模式。<a href="https://www.w3cplus.com/css3/future-css-layouts.html" target="_blank" rel="external">未来布局展望</a></p>
<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>入门布局方式，时间陈旧已遭淘汰 –&gt;&lt;–</p>
<h2 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h2><p>主要采用的是Css的position属性来进行页面布局，实现起来简单粗暴，能让更快速达到想要的布局效果，但就页面的整体架构来讲，真不是一个好的布局方式。</p>
<h2 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h2><p>我看了些资料，其中有人提到其实最早的float属性只是为了规范文本的排版方式，但经过Csser不断努力下，硬是将这个技术运用到了页面布局上，而且这种布局方式渐渐成为一种主流的布局方式，并且持续了很多年。以至于后来不短衍生出新的浮动布局方式，固定布局、流式布局（液体布局）、自适应布局和响应式布局等。就算现在浮动布局依然占有一定的比例。</p>
<h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><p>Flexbox是CSS3中一个新特性，这个特性解决以前在CSS中很多麻烦问题，比如说内容的伸缩与扩展、垂直居中、等分等等。当然，这个属性也大量的运用于布局当中，特别是在现在而对品种繁多的移动终端的局面下，Flexbox用于布局的优势也就愈加明显。慢慢的开始取代了CSS中的浮动布局。</p>
<h2 id="Grid布局（网格布局）"><a href="#Grid布局（网格布局）" class="headerlink" title="Grid布局（网格布局）"></a>Grid布局（网格布局）</h2><p>Grid布局技术现在越来越受到人们的关注，因为CSS Grid布局打破了以前所有布局方式的维度，它是一个双维度的布局模块。它除了可以灵活的控制水平方向之外，还能轻易的控制垂直方向的布局模式。很多资料显示，随着浏览器对其支持度越来越强的情况下，它将更会受到青眯。也将成为未来Web布局中的霸主。</p>
<h2 id="Shapes（图形布局）"><a href="#Shapes（图形布局）" class="headerlink" title="Shapes（图形布局）"></a>Shapes（图形布局）</h2><p>打破矩形设计的限制的一个布局方式，能实现很多有意思的效果。有兴趣可以去了解下。</p>
<h2 id="Regions（区域布局）"><a href="#Regions（区域布局）" class="headerlink" title="Regions（区域布局）"></a>Regions（区域布局）</h2><p>CSS Regions语法为内容流创建了一种高级模型。我们可以通过指定文档的特定区域，让该区域的内容实现“流动显示”的效果——即使指定的这些区域在文档结构中并不相邻。在 web 环境中，这听起来有些怪异，不过，这种布局常常被用于印刷设计，特别是杂志和报纸。</p>
<blockquote>
<p>CSS Regions 并没有提出任何新的布局方法，所以可以使用现有的或将来会出现的方法来定位元素。</p>
</blockquote>
<p>以下是各布局方式在浏览器的兼容情况：<br><img src="/images/buju1.png" alt="1"></p>
<p>流式布局VS响应式布局</p>
<blockquote>
<ul>
<li>流逝布局主要采用的是百分比计算方式，可以通过根据区域长度、宽度的变化进行计算渲染得到的。整体的系统布局样式是不会改变的。</li>
<li>响应式布局主要用的是媒体查询技术，通过识别浏览器的视图的宽度进行，布局样式的调整，也就是说响应式布局相当于，写了几套css样式，根据浏览器的视图大小进行区分调用不同的样式表。</li>
</ul>
</blockquote>
<p>网格布局VS栅格布局</p>
<blockquote>
<ul>
<li>栅格布局其实是浮动布局的一个衍生品，其原理主要是将区域的横向距离等分为若干份，一般等分为24份，我们将这24份作为容器，可以选择一份或几份用于我们的内容填充。每一份都是用的float进行文本排列。</li>
<li>网格布局则跟table布局方式有着异曲同工之处，可以看做是将一个区域进行网格划分，说白话一点就是讲一个区域为几行几列，每行和每列的长度和宽带是多少。我们将内容填充到几行几列的那个格子中去，最经典的就是<strong>九宫格</strong>的实现。</li>
</ul>
</blockquote>
<p>人云亦云</p>
<p>CSS网格布局规范允许我们轻松创建复杂的布局。 我们需要编写的CSS更简单，更易于维护。 我们不再需要使用float在我们的设计创建复杂的布局时，或其他类似性质。 另一个巨大的优势是完全分离标记和布局。 使用CSS网格布局，可能性是无止境的。<br>总结</p>
<p>现在我们经常用到的布局方式多由浮动布局，定位布局，栅格布局，FLexBox布局组合而成，三个现代布局方式现在的支持都不是很好。但毕竟是未来布局方式，无论如何我们都该拥抱未来。</p>
<h2 id="细说纷纭——FlexBox"><a href="#细说纷纭——FlexBox" class="headerlink" title="细说纷纭——FlexBox"></a>细说纷纭——<strong>FlexBox</strong></h2><p>上一次分享中的上下居中问题，提到了flex来解决上下居中是最佳方案，当然前提是不考虑ie兼容性的情况下。但在手机端FlexBox,已经渐渐处于主要布局方式了。所以下面就让我们来了解下FlexBox吧。</p>
<h2 id="均匀排列"><a href="#均匀排列" class="headerlink" title="均匀排列"></a>均匀排列</h2><p>在传统的布局设计中，将一组布局元素沿坐标轴均匀排列是件很麻烦的工作。如果使用浮动布局，那么每个浮动元素都必须设置一个宽度，否则就会宽窄不一。<br>FlexBox则大大的简化了这一过程。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/images/buju2.png" alt="2"></p>
<h2 id="父级元素属性集"><a href="#父级元素属性集" class="headerlink" title="父级元素属性集"></a>父级元素属性集</h2><blockquote>
<ul>
<li>flex-direction：属性决定主轴的方向。</li>
<li>flex-wrap：如果一条轴线排不下，如何换行。</li>
<li>flex-flow：属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</li>
<li>justify-content：属性定义了项目在主轴上的对齐方式。</li>
<li>align-items：属性定义项目在交叉轴上如何对齐。</li>
<li>align-content：属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
</blockquote>
<h2 id="子级元素属性集"><a href="#子级元素属性集" class="headerlink" title="子级元素属性集"></a>子级元素属性集</h2><blockquote>
<ul>
<li>order：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>flex：属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>
<li>align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
</blockquote>
<p>上下居中问题；下面代码即可完成。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.father</span> &#123; </div><div class="line">	<span class="attribute">display</span>:flex;</div><div class="line">	<span class="attribute">background</span>:<span class="number">#bcbcbc</span>;</div><div class="line">	<span class="attribute">justify-content</span>:center;</div><div class="line">	<span class="attribute">align-items</span>:center;</div><div class="line">	<span class="attribute">height</span>:<span class="number">300px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.son</span> &#123;</div><div class="line">	<span class="attribute">background</span>:red;</div><div class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;</div><div class="line">	<span class="attribute">height</span>:<span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class="father"&gt;</div><div class="line">	&lt;div class="son"&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>具体属性用法的讲解教程在<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮一峰Flex教程</a>,如果有想发展移动端的，建议熟悉 我这就不多讲了。</p>
<h2 id="细说纷纭——Grid-未来霸主"><a href="#细说纷纭——Grid-未来霸主" class="headerlink" title="细说纷纭——Grid-未来霸主"></a>细说纷纭——Grid-未来霸主</h2><p>既然人家都是未来霸主了想必我们还是有必要了解下的哈。<br>主要概念</p>
<blockquote>
<p>— 线 ：线定义其它元素的边界。 它们垂直和水平运行。 在下图中，有四条垂直线和四条水平线。<br>— 轨道 ：轨道是平行线之间的空间。 在下图中，有三个垂直和三个水平轨道。<br>— 细胞 ：细胞是网格的构建块。 在下图中，共有9个单元格。<br>— 区域 ：一个区域是与细胞的任意数量的矩形形状。 因此，一个轨道是一个区域 ，并因此是细胞 。<br><img src="/images/buju3.png" alt="3"></p>
</blockquote>
<p>代码表现形式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">	<span class="attribute">-ms-display</span>: grid;</div><div class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">-ms-grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</div><div class="line">    <span class="attribute">-ms-grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;	</div><div class="line">&#125;</div><div class="line">//基于细胞的表现形式</div><div class="line"><span class="selector-class">.area</span> &#123; </div><div class="line">	<span class="attribute">-ms-grid-row</span>: <span class="number">3</span>;</div><div class="line">	<span class="attribute">-ms-grid-row-span</span>: <span class="number">1</span>; </div><div class="line">	<span class="attribute">-ms-grid-column</span>: <span class="number">1</span>;</div><div class="line">	<span class="attribute">-ms-grid-column-span</span>:<span class="number">2</span>; </div><div class="line">&#125;</div><div class="line">//基于线的表现形式</div><div class="line"><span class="selector-class">.area</span> &#123; </div><div class="line">	<span class="attribute">-ms-grid-column-start</span>: <span class="number">1</span>;</div><div class="line">	<span class="attribute">-ms-grid-column-end</span>: <span class="number">3</span>;</div><div class="line">	<span class="attribute">-ms-grid-row-start</span>: <span class="number">3</span>;</div><div class="line">	<span class="attribute">-ms-grid-row-end</span>: <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line">//基于线的简写形式</div><div class="line"><span class="selector-class">.area</span> &#123; </div><div class="line">	<span class="attribute">-ms-grid-column</span>: <span class="number">1</span> / <span class="number">3</span> ;</div><div class="line">	<span class="attribute">-ms-grid-row</span>: <span class="number">3</span> / <span class="number">4</span> ;</div><div class="line">&#125;</div><div class="line">//基于线的最简形态</div><div class="line"><span class="selector-class">.area</span> &#123; </div><div class="line">	<span class="attribute">-ms-grid-area</span>: <span class="number">3</span> / <span class="number">1</span> / <span class="number">4</span> / <span class="number">3</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>span 来实现单元格的跨越，类似于table中的合并单元格，比如colspan合并列，rowspan合并行。span除了可以跨越网格数之外，还可以跨越网格线的名称。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//基于线的简写形式</div><div class="line"><span class="selector-class">.area</span> &#123; </div><div class="line">	<span class="attribute">-ms-grid-column</span>: <span class="number">1</span> / span <span class="number">2</span> ;</div><div class="line">	<span class="attribute">-ms-grid-row</span>: <span class="number">3</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>grid-column-gap和grid-row-gap指定网格线的大小。你可以把它想像成在行/列之间设置间距宽度。</p>
<blockquote>
<p>grid-template-area: 使用grid-area属性定义网格区域名称<br>.: 句点表示一个空单元格<br>none: 无网格区域被定义</p>
</blockquote>
<p>还有更奇妙的Shapes（图形布局），Regions（区域布局）。感兴趣的可以下去了解下。<br><img src="/images/buju4.png" alt="4"></p>
]]></content>
      
        <categories>
            
            <category> Css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Css基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flux]]></title>
      <url>/2017/10/09/Flux/</url>
      <content type="html"><![CDATA[<p>Flux 架构是优雅、简洁的，它合理利用了一些优秀的架构思维。</p>
<h2 id="FLUX"><a href="#FLUX" class="headerlink" title="FLUX"></a>FLUX</h2><p>Flux最早是有 FaceBook 工程师们提出来的，其核心思想是<strong>数据</strong>和<strong>逻辑</strong>永远<strong>单向流动</strong>，Flux应用中数据从 action 到 dispatcher，再到store，最终 view 的线路是不可逆的，数据只能保持这样的方向进行传递。</p>
<p>在使用 React 作为 Flux 的 view 中，记住其每个页面都是先进行页面初始化后由于数据变化触发的重渲染，虽然是重渲染但是其性能比不差，因为重渲染的都是 react 构造的虚拟DOM 即 Virtual DOM,所以在优化 react 性能方面建议引进 PureRender 保障从重渲染到局部渲染的转换。</p>
<p>Flux 强调单向数据流，强调谨慎可追溯的数据变动，这些设计和约束都使得前端应用在越来 越复杂的今天不会失去清晰的逻辑和架构。</p>
<p>一个 Flux 应用由 3 大部分组成——dispatcher、store 和 view，其中 dispatcher 负责分发事件；store 负责保存数据，同时响应事件并更新数据；view 负责订阅 store 中的数据，并使用这些数据 渲染相应的页面。</p>
<h4 id="dispatcher-和-action-及-store"><a href="#dispatcher-和-action-及-store" class="headerlink" title="dispatcher 和 action 及 store"></a>dispatcher 和 action 及 store</h4><p>action 是一个普通的 JavaScript 对象，一般包含 type、payload 等字段，用于描述一个事件以及需要改变的相关数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type: <span class="string">"action的标识"</span>， <span class="comment">//必须字段</span></div><div class="line">    payload: <span class="string">"数据可是字符串也可以是对象"</span>，</div><div class="line">    error: <span class="string">"错误信息"</span></div><div class="line">&#125;</div><div class="line">字段多少由应用的复杂度决定</div></pre></td></tr></table></figure></p>
<p>dispatcher的作用就是发起action和识别action，对应的俩个API是dispatcher.dispatch()和dispatcher.register()。</p>
<p>对应到的文件即dispatcher.dispatch()多用于action.js文件中，<br>dispatcher.register()多存在于store.js中。下面为示例代码</p>
<p>action.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> action = &#123;  <span class="comment">//action</span></div><div class="line">    type: <span class="string">"success"</span>,  <span class="comment">//action 类型</span></div><div class="line">    payload: <span class="string">"成功了"</span>  <span class="comment">//action 携带的数据</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">     getFilterList() &#123;Dispatcher.dispatch(action)&#125; <span class="comment">//发起dispatch 分发action</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>store.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断action的类型做出数据存储</span></div><div class="line"><span class="keyword">import</span> &#123; EventEmitter &#125; <span class="keyword">from</span> <span class="string">'events'</span>; </div><div class="line"><span class="keyword">import</span> assign <span class="keyword">from</span> <span class="string">'object-assign'</span>; </div><div class="line"><span class="keyword">let</span> data = &#123;&#125;;</div><div class="line"><span class="keyword">const</span> Store = assign(&#123;&#125;, EventEmitter.prototype, &#123;</div><div class="line">    getData() &#123; <span class="keyword">return</span> data; &#125;, <span class="comment">//通过Store.getData()可以拿到用data变量存储起来的action.payload数据</span></div><div class="line">    emitChange() &#123; <span class="keyword">this</span>.emit(<span class="string">'change'</span>); &#125;, <span class="comment">//触发改变以便于在view层监听</span></div><div class="line">    addChangeListener(callback) &#123; <span class="keyword">this</span>.on(<span class="string">'change'</span>, callback); &#125;,</div><div class="line">    removeChangeListener(callback) &#123; <span class="keyword">this</span>.removeListener(callback); &#125;</div><div class="line">&#125;);</div><div class="line">Dispatcher.register(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">        <span class="keyword">case</span> success:</div><div class="line">            data = action.payload;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">    &#125;</div><div class="line">    Store.emitChange();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Store;</div></pre></td></tr></table></figure></p>
<h4 id="view"><a href="#view" class="headerlink" title="view"></a>view</h4><p>以react为例，<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">react</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">     <span class="keyword">constructor</span>(props) &#123; </div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">data</span>: Store.getData(), &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    onChange=<span class="function"><span class="params">()</span>=&gt;</span> &#123; </div><div class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">data</span>: Store.getData(), &#125;); <span class="comment">//Store 有改变时及时获取最新数据</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123; </div><div class="line">        Store.addChangeListener(<span class="keyword">this</span>.onChange); <span class="comment">//添加监听事件</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentWillUnmount() &#123; </div><div class="line">        Store.removeChangeListener(<span class="keyword">this</span>.onChange); <span class="comment">//删除监听事件</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Flux的优缺点"><a href="#Flux的优缺点" class="headerlink" title="Flux的优缺点"></a>Flux的优缺点</h2><p>生活应该看到美好面，所以我们先来看看Flux的优点：</p>
<blockquote>
<ol>
<li>数据单向流动，在很大程度上让应用的逻辑变得更加清晰。</li>
<li>数据分离，使得view层更加简洁明了，不需要关心太多的逻辑，只需要关注取得的数据。</li>
<li>中心化控制让人称道。中心化控制让所有的请求与改变都只能通过 action 发出，统一 由 dispatcher 来分配.</li>
</ol>
</blockquote>
<p>有光的地方必定会有阴影的存在。Flux的缺点也随着人们的使用逐渐暴露出来：</p>
<blockquote>
<ol>
<li>Flux 的冗余代码太多，我们写一个store的时候必然会实例化一个dispatcher.</li>
<li>我们需要创建多个store来管理不同页面的数据分发，但每个store的action都挂载在同一个 dispatcher.register() 上，也就是说这里的 register 函数监听的是整个应用所有的Dispatcher.dispatch(),每一个 dispatch 函数都会触发所有store文件中的 register 函数，这样一来如果程序足够复杂，那冗余的执行代码将大大增加。</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flux 与 MVC 架构下不同的触发方式管理混乱相比，Flux 要优雅许多。同时也为我们提供了一条新的架构思路，也为更好的前端架构框架redux做到了启迪作用。总体上是优雅的、简洁的。</p>
]]></content>
      
        <categories>
            
            <category> 前端架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redux]]></title>
      <url>/2017/10/09/redux/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>“Redux”本身指 redux 这个 npm 包，它提供若干 API 让我们使用 reducer 创建 store，并能够 更新 store 中的数据或获取 store 中最新的状态。而“Redux 应用”则是指使用了 redux 这个 npm 包 并结合了视图层实现（如 React）及其他前端应用必备组件（路由库、Ajax 请求库）组成的完整 的类 Flux 思想的前端应用。[深入react技术栈][1]<br>Redux就其本身而言，其实就是基于Flux思想的完善与改进。作者也是为了通过Flux思想解决他的热重载和时间旅行的问题而已。如果你有接触过Flux，那理解Redux就及其容易了</p>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><blockquote>
<ol>
<li>单一数据源</li>
<li>状态是只读的</li>
<li>状态修改均由纯函数完成</li>
</ol>
</blockquote>
<h2 id="关联组件"><a href="#关联组件" class="headerlink" title="关联组件"></a>关联组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;)(Component)</div></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SchedulerHistoryContainer = connect(</div><div class="line">    mapStateToProps,</div><div class="line">    mapDispatchToProps</div><div class="line">)(SchedulerHistory);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> SchedulerHistoryContainer;</div></pre></td></tr></table></figure></p>
<p>1.mapStateToProps:</p>
<p>我们需要从 Redux 状态树中提取哪些部分当作 props 传给当前 组件。一般来说，这也是我们使用 connect 时经常传入的参数。事实上，如果不传入这个参数， React 组件将永远不会和 Redux 的状态树产生任何关系。</p>
<p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        historyList: state.history.history,</div><div class="line">        historyDetil: state.history.historyDetil,</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.mapDispatchToProps:</p>
<p>我们可以在 connect 中方便地将 actionCreator 与 dispatch 绑定在一起 （利用 bindActionCreators 方法），最终绑定好的方法也会作为 props 传给当前组件.</p>
<p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> bindActionCreators(&#123;</div><div class="line">        ActionGetHistory,</div><div class="line">        ActionGetHistoryDetil</div><div class="line">    &#125;, dispatch);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.mergeProps</p>
<p>根据文档中的定义， mergeProps 参数也是一个函数，接受 stateProps、 dispatchProps 和 ownProps 作为参数。实际上，stateProps 就是我们传给 connect 的第一个参数 mapStateToProps 最 终返回的 props。同理，dispatchProps 是第二个参数的最终产物，而 ownProps 则是组件自己的 props。这个方法更大程度上只是为了方便对三种来源的 props 进行更好的分类、命名和重组。</p>
<p>4.options</p>
<p>connect 参数接受的最后一个参数是 options，其中包含了两个配置项。</p>
<p> pure：布尔值，默认为 true。当该配置为 true 时，Connect 中会定义 shouldComponentUpdate 方法并使用浅对比判断前后两次 props 是否发生了变化，以此来减少不必要的刷新。如果 应用严格按照 Redux 的方式进行架构，该配置保持默认即可。</p>
<p>  withRef：布尔值，默认为 false。如果设置为 true，在装饰传入的 React 组件时，Connect 会保存一个对该组件的 refs 引用，你可以通过 getWrappedInstance 方法来获得该 refs， 并最终获得原始的 DOM 节点。</p>
<h2 id="打包redux"><a href="#打包redux" class="headerlink" title="打包redux"></a>打包redux</h2><p>// 使用 redux 的 combineReducers 方法 <br><br>// 将所有 reducer 打包起来</p>
<p>reducer<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initState = &#123;</div><div class="line">    history: &#123;&#125;,</div><div class="line">    historyDetil:&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ReducerHistory</span>(<span class="params">state = initState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">        <span class="keyword">case</span> ActionType.GET_HISTORY:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">                history: action.data</div><div class="line">            &#125;);<span class="comment">//覆盖history 返回新的state</span></div><div class="line">        <span class="keyword">case</span> ActionType.GET_HISTORY_DETIL:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">                historyDetil: action.data</div><div class="line">            &#125;);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">    routing: routerReducer,</div><div class="line">    scheduler: ReducerScheduler,</div><div class="line">    history:ReducerHistory</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</div></pre></td></tr></table></figure></p>
<p>combineReducers:<br><br>其实就是一个高阶 reducer,<br>通过这个方法，我们可以方便地将多个 reducer 合并为一个。</p>
<h2 id="生成store"><a href="#生成store" class="headerlink" title="生成store"></a>生成store</h2><p>const store = createStore(<br>    reducer,<br>    enhancer<br>);</p>
<p>export default store;</p>
<p>基本上， Redux 的核心功能已经全部被囊括在 createStore 及 createStore 方法最终生成的 store 中。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 提供了一个组件和一个 API 帮助 Redux 和 React 进行绑定，一个是 React 组件 <provider> ，一个是 connect()。关于它们，只需要知道的是， <provider> 接受一个 store 作为<br>props，它是整个 Redux 应用的顶层组件，而 connect() 提供了在整个 React 应用的任意组件中获 取 store 中数据的功能。</provider></provider></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../redux/store'</span>;</div><div class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">'../redux/history'</span>;</div><div class="line"><span class="keyword">import</span> route <span class="keyword">from</span> <span class="string">'../route'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> oApp = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>);</div><div class="line"></div><div class="line">render((</div><div class="line">    &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;div className=<span class="string">"full-screen"</span>&gt;</div><div class="line">            &#123;route(history, store)&#125;</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>Provider&gt;</div><div class="line">), oApp);</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 前端架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Css值和单位]]></title>
      <url>/2017/09/22/Css%E5%8D%95%E4%BD%8D/</url>
      <content type="html"><![CDATA[<h1 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h1><p>css的所有工作大多都是基于单位的，这是影响所有属性的颜色、距离和大小的一种元素。</p>
<h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><p>单位总览：</p>
<table width="500"><br><tbody><tr><br><th scope="col">单位</th><br><th scope="col">解释</th><br></tr><br><tr><br><td>em</td><br><td>相对于父元素的字体大小</td><br></tr><br><tr><br><td>ex</td><br><td>相对于小写字母”x”的高度</td><br></tr><br><tr><br><td>gd</td><br><td>一般用在东亚字体排版上，这个与英文并无关系</td><br></tr><br><tr><br><td>rem</td><br><td>相对于根元素字体大小</td><br></tr><br><tr><br><td>vw</td><br><td>相对于视窗的宽度：视窗宽度是100vw</td><br></tr><br><tr><br><td>vh</td><br><td>相对于视窗的高度：视窗高度是100vh</td><br></tr><br><tr><br><td>vm</td><br><td>相对于视窗的宽度或高度，取决于哪个更小</td><br></tr><br><tr><br><td>ch</td><br><td>相对于0尺寸</td><br></tr><br><tr><br><td>px</td><br><td>相对于屏幕分辨率而不是视窗大小：通常为1个点或1/72英寸</td><br></tr><br><tr><br><td>in</td><br><td>inch, 表英寸</td><br></tr><br><tr><br><td>cm</td><br><td>centimeter, 表厘米</td><br></tr><br><tr><br><td>mm</td><br><td>millimeter, 表毫米</td><br></tr><br><tr><br><td>pt</td><br><td>1/72英寸</td><br></tr><br><tr><br><td>pc</td><br><td>12点活字，或1/12点</td><br></tr><br><tr><br><td>%</td><br><td>相对于父元素。正常情况下是通过属性定义自身或其他元素</td><br></tr><br></tbody></table>

<p>常用单位：</p>
<blockquote>
<ul>
<li>px:新手必备单位，用得最普遍的单位之一，属于绝对长度单位</li>
<li>%:学了些基础在考虑流式布局的时候用得较多，属于相对长度单位</li>
<li>em:弹性布局初期选择之一，属于相对长度单位</li>
<li>rem:弹性布局成熟选择之一，属于相对长度单位</li>
<li>vw、vh、vm:基于window.innerWidth/window.innerHeight的相对单位</li>
</ul>
</blockquote>
<h3 id="em-有坑"><a href="#em-有坑" class="headerlink" title="em (有坑)"></a>em (有坑)</h3><p>定义是相对于父元素的字体大小。但经过实践证明并非如此。<br>分为俩种情况讨论</p>
<blockquote>
<ol>
<li>字体大小：任何情况下字体大小也就是font-size与父元素是保持高度一致的，也就是1em就等于父元素的font-size。</li>
<li>非字体大小或者长度：具体有boder、width、height、padding、margin、line-height等属性的值,是根据子元素的font-size进行计算的，也就是这里的1em其实是等于子元素的font-size。<a href="https://codepen.io/zizhi/pen/aLmmGR" target="_blank" rel="external">例子</a></li>
</ol>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">div</span>&gt;</div><div class="line">  &lt;span&gt;1&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>:<span class="number">24px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">span</span>&#123;</div><div class="line">  <span class="attribute">font-size</span>:<span class="number">12px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">span</span> &#123;</div><div class="line">   <span class="attribute">border</span>:<span class="number">1em</span> solid <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中border里的1em就是等于12px，而不是等于24px;这里还有一种理解，如果你没设置子元素的font-size时，其实em也是根据子元素的font-size计算的，因为这是子元素的font-size是继承于父元素的。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>定义：相对于根元素html元素字体大小，这能给我们带来什么好处呢，就是我们在rem时只需要根据媒体查询便能轻松的改变整个页面的大小，实现弹性布局的效果。是比较好的弹性布局方案之一了</p>
<h3 id=""><a href="#" class="headerlink" title="%"></a>%</h3><p>百分比，在我们日常的代码写作中用的也比较多。<br>这里介绍个不常用的能用百分比单位的属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vertical-align:10%; //基于文本基线上浮10%个line-height高度</div></pre></td></tr></table></figure></p>
<h2 id="时间、频率、角度"><a href="#时间、频率、角度" class="headerlink" title="时间、频率、角度"></a>时间、频率、角度</h2><p>单位总览:</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>deg</td>
<td>degrees, 角度</td>
</tr>
<tr>
<td>grad</td>
<td>grads, 百分度</td>
</tr>
<tr>
<td>rad</td>
<td>radians, 弧度</td>
</tr>
<tr>
<td>turn</td>
<td>turns, 圈数</td>
</tr>
<tr>
<td>ms</td>
<td>milliseconds, 毫秒数</td>
</tr>
<tr>
<td>s</td>
<td>seconds, 秒数</td>
</tr>
<tr>
<td>Hz</td>
<td>Hertz, 赫兹</td>
</tr>
<tr>
<td>kHz</td>
<td>kilohertz, 千赫</td>
</tr>
</tbody>
</table>
<p>这些单位多用于显示动画或者canvas和svg的绘图中用得较多</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>16进制颜色、rgb颜色和hsl颜色，其中rgb颜色实际上和16进制颜色是近亲，只是进制的差异，都归属于rgb颜色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#ff80e1</span></div><div class="line">这里可以直接换算出来<span class="selector-tag">rgb</span>的颜色值</div><div class="line"><span class="selector-tag">rgb</span>(255,128,225);其中255是<span class="selector-tag">ff</span>换算出来的，128是80换算出来的，225是<span class="selector-tag">e1</span>换算出来的</div><div class="line"><span class="selector-tag">rgb</span>还可以用百分比进行标识</div><div class="line"><span class="selector-tag">rab</span>(100%,82%,88%);100%标识的色值为255.</div></pre></td></tr></table></figure>
<p>hsl颜色中“HSL”所表示的是“H:色相”，“S：饱和度”，“L：亮度”。色相是在色盘上的颜色，颜色的选择是使用饱和度：“0度是红色”，“120度为绿色”和“240度为蓝色”。hsl大多用于工业用色，我们相对用的较少。</p>
<p>hsl和rgb都衍生出了hsla和rgba<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">hsla</span>(200,30%,60%,<span class="selector-class">.8</span>);</div><div class="line"><span class="selector-tag">rgb</span>(255,128,225,<span class="selector-class">.8</span>);</div><div class="line">这里的最后一个数字代表的是透明度，值得范围在0<span class="selector-tag">-1</span>，1标识不透明，0标识完全透明</div></pre></td></tr></table></figure></p>
<p>transparent关键字，可以近似认为是rgba(0,0,0,0)。用这个关键字可以实现很多效果比如三角形 <a href="https://codepen.io/zizhi/pen/PjZNgZ" target="_blank" rel="external">例子</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上纯属个人观点，文章如有表述不准确,欢迎到[项目][5]中提ISSUE,也希望能给您的学习带来一丝帮助。</p>
]]></content>
      
        <categories>
            
            <category> Css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Css基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Css选择器]]></title>
      <url>/2017/09/20/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>Css选择器 会用易用好则难</p>
<h1 id="Css选择器基础"><a href="#Css选择器基础" class="headerlink" title="Css选择器基础"></a>Css选择器基础</h1><p>选择器主要分为以下几类</p>
<blockquote>
<ul>
<li>元素选择器</li>
<li>类选择器</li>
<li>Id选择器</li>
<li>子类选择器</li>
<li>属性选择器</li>
<li>兄弟选择器</li>
<li>伪类和伪元素选择器</li>
</ul>
</blockquote>
<p>前面4类选择器使我们常用到的，相较而言与我们比较熟悉，这里我们变不再做过多赘述了。</p>
<p>后面3类选择器我们不常用到，但其实妙用大多来自这3类选择器中，尤其是伪类和伪元素选择器提供了相当强大的功能。下面就让我们来了解一下。</p>
<h2 id="1-属性选择器"><a href="#1-属性选择器" class="headerlink" title="1.属性选择器 [ ]"></a>1.属性选择器 [ ]</h2><p>属性选择器是基于元素选择器、类选择器和Id选择器之上的，也就是说你不能直接定位到有这个属性的元素，而是需要指定哪一类文档元素有或者没有该属性。<br>代码示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img[alt] &#123;border: 1px solid #333&#125; //找到拥有alt属性的图片元素，加边框</div><div class="line">p[class="info-p"] &#123;color: gray&#125;   //找到拥有类名为info-p的段落元素，将字体变为红色</div></pre></td></tr></table></figure></p>
<p>妙用场景：</p>
<blockquote>
<p> 基于Css的过滤搜索技术 <a href="http://www.zhangxinxu.com/wordpress/2013/09/css-attr-selector-search/" target="_blank" rel="external">详情&gt;&gt;</a></p>
</blockquote>
<h3 id="衍生出来‘部分属性选择器’"><a href="#衍生出来‘部分属性选择器’" class="headerlink" title="衍生出来‘部分属性选择器’"></a>衍生出来‘部分属性选择器’</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img[alt~="info"] //找到拥有alt属性中包含'info'单词的图片元素 * 这里的'info'必须为整体不能为字符串的一部分 例如&lt;img alt="info-danger"/&gt;不能匹配得到，而&lt;img alt="info danger"/&gt;可以匹配得到</div><div class="line">img[alt^="info"] //找到拥有alt属性以'info'字符开头的图片元素</div><div class="line">img[alt$="info"] //找到拥有alt属性以'info'字符结束的图片元素</div><div class="line">img[alt*="info"] //找到拥有alt属性中包含'info'字符的图片元素 * 这里的'info'可以为字符串的一部分 例如 &lt;img alt="info-danger"/&gt;可以匹配得到</div></pre></td></tr></table></figure>
<h2 id="2-兄弟选择器"><a href="#2-兄弟选择器" class="headerlink" title="2.兄弟选择器"></a>2.兄弟选择器</h2><p>兄弟选择器由普通兄弟元素选择器(~)与相邻兄弟元素选择器(+)组成；都是选择第一个元素后面出现的兄弟元素。</p>
<h3 id="2-1普通兄弟选择器"><a href="#2-1普通兄弟选择器" class="headerlink" title="2.1普通兄弟选择器 ~"></a>2.1普通兄弟选择器 ~</h3><p>定义：选择紧接着一个原素后的<strong>所有</strong>指定元素，而且俩着拥有着相同的父级。<br>代码示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h1 ~ p &#123;font-size:24px;margin&#125; //选择紧接着在h1元素后面的所有p元素，h1和p拥有着相同的父级元素</div></pre></td></tr></table></figure></p>
<h3 id="2-2相邻兄弟选择器"><a href="#2-2相邻兄弟选择器" class="headerlink" title="2.2相邻兄弟选择器 +"></a>2.2相邻兄弟选择器 +</h3><p>定义：选择紧接着一个原素后的<strong>第一个</strong>指定元素，而且俩着拥有着相同的父级。<br>代码示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h1 + p &#123;font-size:24px;margin&#125; //选择紧接着在h1元素后面的第一个p元素，h1和p拥有着相同的父级元素</div></pre></td></tr></table></figure></p>
<p>应用场景<br>普通兄弟选择器：<br>默认字体为12px<br>要求是div下的第一个span的字体大小为12px,其余span的字体大小为24<br>代码示例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span> ~ <span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>:<span class="number">24px</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="3-伪类和伪元素选择器-important"><a href="#3-伪类和伪元素选择器-important" class="headerlink" title="3 伪类和伪元素选择器  //!important"></a>3 伪类和伪元素选择器  //!important</h2><p>这里要着重区别下 伪类和伪元素</p>
<p>伪类：类似通常HTML中的类，但是它们不会直接以html标记的形式定义，而是一个动态的，满足一定条件时才会显示出来特定的效果。</p>
<p>伪元素：主要这里的用词是元素，虽然是不存在于dom树种，但其本质还是一种动态元素。</p>
<h3 id="3-1-伪类-important-and-important"><a href="#3-1-伪类-important-and-important" class="headerlink" title="3.1 伪类 //!important and !important"></a>3.1 伪类 //!important and !important</h3><p>伪类总集</p>
<table><br>    <thead><br>        <tr><br>            <th>例子</th><br>            <th>类别</th><br>            <th>解释</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td><br>                a:link</td><br>            <td><br>                链接(link)伪类</td><br>            <td><br>                选择一个用户没有访问过的链接</td><br>        </tr><br>        <tr><br>            <td><br>                a:visited</td><br>            <td><br>                链接(link)伪类</td><br>            <td><br>                选择一个用户访问过的链接</td><br>        </tr><br>        <tr><br>            <td><br>                a:hover</td><br>            <td><br>                行为性伪类</td><br>            <td><br>                选择一个用户将鼠标指针悬浮在上方的元素</td><br>        </tr><br>        <tr><br>            <td><br>                a:active</td><br>            <td><br>                行为性伪类</td><br>            <td><br>                选择一个用户使用中的元素</td><br>        </tr><br>        <tr><br>            <td><br>                a:focus</td><br>            <td><br>                行为性伪类</td><br>            <td><br>                选择一个拥有用户焦点的元素</td><br>        </tr><br>        <tr><br>            <td><br>                input:enabled</td><br>            <td><br>                状态性伪类</td><br>            <td><br>                选择一个处于可编辑状态(默认)下的元素</td><br>        </tr><br>        <tr><br>            <td><br>                input:disabled</td><br>            <td><br>                状态性伪类</td><br>            <td><br>                选择一个通过设置disabled属性而处于不可编辑状态下的元素</td><br>        </tr><br>        <tr><br>            <td><br>                input:checked</td><br>            <td><br>                状态性伪类</td><br>            <td><br>                选择一个被选中的单选或者复选按钮</td><br>        </tr><br>        <tr><br>            <td><br>                input:indeterminate</td><br>            <td><br>                状态性伪类</td><br>            <td><br>                选择一个处于不确定状态下的单选或者复选按钮(可能被选中或者不被选中)</td><br>        </tr><br>        <tr><br>            <td><br>                li:first-child</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素下的第一个子元素</td><br>        </tr><br>        <tr><br>            <td><br>                li:last-child</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素下的最后一个子元素</td><br>        </tr><br>        <tr><br>            <td><br>                div:only-child</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                如果某个元素是它父元素中惟一的子元素,那么将会被匹配</td><br>        </tr><br>        <tr><br>            <td><br>                p:first-of-type</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素中同类型的第1个子元素</td><br>        </tr><br>        <tr><br>            <td><br>                p:last-of-type</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素中同类型的最后一个子元素</td><br>        </tr><br>        <tr><br>            <td style="color:red"><br>                img:only-of-type</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                若元素为父元素中<strong>同类型的唯一元素<strong>，则会被匹配</strong></strong></td><br>        </tr><tr><td style="color:red"><br>                li:nth-child(2n+3)</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择以第3个子元素为开始，2为等差数向后递增的子元素中，如果该子元素为li元素则样式生效，不是li元素样式不会生效。即选中 3 5 7 9 11 … 中是li元素的子元素赋予样式</td><br>        </tr><tr><td style="color:red"><br>                li:nth-last-child(3n+2)</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择以倒数第二个子元素为开始，3为等差数向前递减的子元素中，如果该子元素为li元素样式生效，不是li元素样式不会生效</td><br>        </tr><tr><td style="color:red"><br>                p:nth-of-type(3n)</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素下的所有p元素提取出来，以0为开始，3为等差数向后递增的p元素，对子元素的排序没有要求,即俩个p元素之间可以插入任意多个元素，不会影响最终效果</td><br>        </tr><tr><td style="color:red"><br>                p:nth-last-of-type(2n+1)</td><br>            <td><br>                结构性伪类</td><br>            <td><br>                选择父元素下的所有p元素提取出来，以倒数第一个p元素为开始，2为等差数向前递减的p元素，对子元素的排序没有要求，即俩个p元素之间可以插入任意多个元素，不会影响最终效果</td><br>        </tr><tr><td><br>                section:target</td><br>            <td><br>                目标伪类</td><br>            <td><br>                选择URI片段标示符的值指向的元素</td><br>        </tr><tr><td><br>                div:empty</td><br>            <td><br>                空伪类</td><br>            <td><br>                选择没有任何子元素或者文本的元素</td><br>        </tr><tr><td><br>                div:not(.awesome)</td><br>            <td><br>                否定伪类</td><br>            <td><br>                选择不匹配某个状态标示符的元素</td><br>        </tr><br>    </tbody><br></table>

<p>介绍几个常用的伪类</p>
<h4 id="first-child"><a href="#first-child" class="headerlink" title=":first-child"></a>:first-child</h4><p>选择父元素下的第一个子元素<br>示例代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;<span class="attribute">font-size</span>:<span class="number">24px</span>&#125;</div></pre></td></tr></table></figure></p>
<p>注意一下这里选择的并不是第一ul下的第一个li,也不是所有ul下的第一个li,而是所有的ul下的第一个子元素为li的元素集合.</p>
<h4 id="last-child"><a href="#last-child" class="headerlink" title=":last-child"></a>:last-child</h4><p>选择父元素下的最后一个子元素<br>示例代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;<span class="attribute">font-size</span>:<span class="number">24px</span>&#125;</div></pre></td></tr></table></figure></p>
<p>同理这里选择的并不是第一ul下的最后一个li,也不是所有ul下的第一个li,而是选择的是所有的ul下的最后一个子元素为li的元素集合.</p>
<h4 id="nth-child"><a href="#nth-child" class="headerlink" title=":nth-child"></a>:nth-child</h4><p>当父元素中子元素的序列匹配所给数字时会被选中，会以文档树开头作为起点，来计算所有元素<br>示例代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">table tr td:nth-child(odd)&#123;background:#fcfcfc&#125; //给表格奇数行加背景色</div><div class="line">table tr td:nth-child(2n+0)&#123;background:#fcfcfc&#125; //给表格偶数行加背景色</div><div class="line">table tr td:nth-child(2n+3)&#123;background:#fcfcfc&#125; //给表格3行为开始，2为等差的行数加背景色</div></pre></td></tr></table></figure></p>
<h4 id="nth-of-type"><a href="#nth-of-type" class="headerlink" title=":nth-of-type"></a>:nth-of-type</h4><p>选择父元素中指定类型的子元素按序列匹配<br>示例代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p:nth-of-type(3n) &#123;font-size:24px&#125; //选择父元素下的所有p元素提取出来，以0为开始，3为等差数向后递增的p元素，对子元素的排序没有要求,即俩个p元素之间可以插入任意多个元素，不会影响最终效果</div></pre></td></tr></table></figure></p>
<p>总结下</p>
<blockquote>
<ol>
<li>所有伪类中带child的，针对的是父元素下的<strong>所有</strong>子元素集进行排序,而所有伪类中带type的，针对的是父元素下的<strong>指定</strong>元素集进行排序</li>
<li>(2n+0)的表达式中 n旁边的数字代表等差数，+号左或者右的数字代表起始计算位置。</li>
<li>所有伪类选择的都是一个元素集，并不是单一元素，直选中单一元素只是应为你只有一个元素是满足选择条件的。 </li>
</ol>
</blockquote>
<h3 id="3-1-伪元素-important-and-important"><a href="#3-1-伪元素-important-and-important" class="headerlink" title="3.1 伪元素 //!important and !important"></a>3.1 伪元素 //!important and !important</h3><p>伪元素总集</p>
<p><table><thead><tr><th><br>                例子</th><br>            <th><br>                类别</th><br>            <th><br>                解释</th><br>        </tr></thead><tbody><tr><td><br>                .alpha:first-letter</td><br>            <td><br>                文本伪元素</td><br>            <td><br>                选择元素内文本的第一个字母</td><br>        </tr><tr><td><br>                .bravo:first-line</td><br>            <td><br>                文本伪元素</td><br>            <td><br>                选择元素内文本的第一行</td><br>        </tr><tr><td><br>                div:before</td><br>            <td><br>                生成的内容</td><br>            <td><br>                在被选择元素前创建伪元素</td><br>        </tr><tr><td><br>                a:after</td><br>            <td><br>                生成的内容</td><br>            <td><br>                在被选择元素末尾创建伪元素</td><br>        </tr><tr><td><br>                ::selection</td><br>            <td><br>                片段伪元素</td><br>            <td><br>                选择通过用户操作所选定或者高亮的部分</td><br>        </tr><br>    </tbody><br></table><br>介绍俩常用的伪元素</p>
<h4 id="before和-after-important-and-important-and-important"><a href="#before和-after-important-and-important-and-important" class="headerlink" title=":before和:after   //!important and !important and !important"></a>:before和:after   //!important and !important and !important</h4><p>before与:after生成内容伪元素向被选择的元素内部追加新的行内伪元素。这一类伪元素最普遍的用法，是配合content属性，向页面内添加一些不太重要的内容，但并不常常如此。伪元素不需要使用额外的元素标签，就可以向页面添加一些用户界面相关的内容。</p>
<p>这俩个伪元素常被我们用来实现一些特殊的效果</p>
<blockquote>
<ol>
<li>特殊形状的图形 <a href="https://codepen.io/zizhi/pen/OggxKW" target="_blank" rel="external">例子</a></li>
<li>字符animation loading效果 <a href="http://www.zhangxinxu.com/wordpress/2016/11/css-content-pre-animation-character-loading/" target="_blank" rel="external">例子</a></li>
<li>:after伪类+content内容生成经典应用举例 <a href="http://www.zhangxinxu.com/wordpress/2010/09/after%E4%BC%AA%E7%B1%BBcontent%E5%86%85%E5%AE%B9%E7%94%9F%E6%88%90%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/" target="_blank" rel="external">例子</a></li>
</ol>
</blockquote>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>其实一个页面的结构一定程度上影响了写css时，对选择器的选择。建议先整体构思页面结构，找出如何才能更少，更简单地使用的css的选择器就能实现你想要的页面效果。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上纯属个人观点，文章如有表述不准确,欢迎到<a href="https://github.com/wangzizhi/wangzizhi.github.io/issues" target="_blank" rel="external">项目</a>中提ISSUE,也希望能给您的学习带来一丝帮助。</p>
]]></content>
      
        <categories>
            
            <category> Css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Css基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初出]]></title>
      <url>/2017/09/16/%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>第一个blog，记录下这一路</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活足迹 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[友情链接]]></title>
      <url>/friends/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
